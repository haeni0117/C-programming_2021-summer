# 포인터 1강
------
포인터(pointer) : 주소를 가지고 있는 변수 
- 인간의 주소체계와 다르기 때문에 이해하기 어려운 내용이다
변수는 어디에 저장되냐? 메모리
- 메모리는 바이트 단위로 액세스된다. 주소 -> 바이트 단위
## 변수와 메모리
- 변수의 크기에 따라서 차지하는 메모리 공간이 달라진다. => 바이트 단위의 주소 체계
- e.g. char형 변수 : 1바이트 int형 변수 : 4바이트
-> 운영체제가 매핑테이블을 만들어서 관리한다고 생각하면 된다. 
## 변수의 주소
- 변수의 주소를 계산하는 연산자 : &
- 변수 i의 주소 : $i -> 변수의 주소에 접근할 수 있음
### 변수 출력하기 예제
```
#include <stdio.h>

int main(){
  int i=10;
  char c='a';
  float f=12.4;
  
  printf("i=%d,&i=%p\n",i,&i);//지금 %d는 정수형을 받고, %p는 pointer로서 주소를 받는다고 이해하면 된다.
  printf("c=%d,&c=%p\n",c,&c);
  printf("f=%f,&f=%p\n",f,&f);
  
  return 0;
  }
  ```
  컴파일 할 때마다 할당받는 위치가 달라진다(주소)
  ## 포인터의 선언
  포인터 : 변수의 주소를 가지고 있는 변수
  - syntax : `int *p;`
  - 헷갈리는 지점 : 포인터를 선언할 때도 사용되고 + 접근할 때도 사용된다.
  - \*p는 예를 들어 데이터타입이 int라면 int형 자료를 받는 것이 아니라 그 자료의 주소를 받는 변수가 되는 것이다. -> address가 들어가야 함
  - 포인터변수라고 하는 이유? anyway 포인터도 변수이기 때문이다. 
  - `int *p;` : 할당은 안해주고 선언만 해준다면? 쓰레기값이 들어있는 것과 마찬가지 why? 아직 데이터를 선언해주지 않았으니까
    - python,java와 다른 점 : python과 java에서는 할당해주지 않은 채로 선언만 해주면 데이터값이 0이 들어가 있는데, c는 알 수 없는 값(literally 쓰레기값)이 들어있더라.. 아마 구닥다리 언어라서 그런건지..
  - int형과 char형이 byte값이 다르기는 하지만 같은 주소체계를 공유한다. -> 집이 넓다고 해서/좁다고 해서 주소부여방식이 변하는 게 아니기 때문이다.
    - 데이터타입은 왜 지정해주냐? 주소가 1000byte라면? 1000~ 어디까지인지 알 수가 없다. 이를 알게해주는 것이 데이터타입!
      - 만약 데이터타입이 정수형(int)라면 1000 1001 1002 1003까지 읽어라!라고 할 수 있다.
    - `int i = 10;`일 때 i의 주소가 3 4 5 6 이라고 가정하자.(일단 정수형int니까!) 그런데 이 i의 주소를 변수로 받아온다면 그 값은 3이 된다. 물론 한 변수에 데이터가 여러개라는 컨셉 자체가 말이 안되긴 하지만(함수의 개념을 벗어나니까), 첫 번째 주소를 변수로 가진다.
    - int : 4byte 
    - char : 1byte
    - double : 8byte 

## 절대 주소 사용
- 아두이노, 라즈베리 파이와 같은 임베디드 시스템에서는 가능하다
- 윈도우는 안된다.
- `int *p = (int*)10000;` -> 10000 10001 10002 10003 이라고 사용자가 임의로 지정하겠다는 것이다.
- 메모리 주소의 관리담당  : OS 
  - 나도 모르는 사이에 내가 지정하려는 주소값에서 뭔가 중요한 일을 하고 있을 수도 있는데, 사용자가 지맘대로 주소를 지정한다? 큰 문제가 생길 수 있다...
  ```
  char *p = (char*)0x30000000;
  *p=0;
  ```
  - 사실 엄밀하게 말하자면 첫번째 라인은 가능하다. 지정만 해주는 거니까! 그런데 여기다가 0처럼 값을 넣어버리는 것이 불가능하다는 소리
  - 뭔가 다른 중요한 일을 하고 있었는데 10이라는 값을 넣어주면, 원래 하던 <그 중요한 일>은 못하게 되기 때문임. -> 프로그램 망!(물론 OS가 못하게 하긴 한다.)

## 포인터와 변수의 연결
```
int i = 10;
int *p; //*의 의미 : 나는 주소를 저장할 변수야 !! 그냥 변수가 아니야 ~
p = &i; //p라는 변수에 i의 주소를 할당한다.
```
```
int *p = &i;
```
위의 두 코드 동일한 표현이다.

## 다양한 포인터의 선언
- 직접참조
```
char c = 'A'
float f = 36.5;
double d = 3.143425;
```
- 간접참조 : 다른 영역에 있는 주소를 화살표에 의해서 할당해주는 것이기 때문이다. 
```
char *pc = &c;
float *pf = &f;
double *pd = &f;
```
일반 변수도 초기화하지 않으면 문제가 발생한다.
-> 프로그램 응용할 때(고난도), 포인터를 자유자재로 사용해야 한다.
- 선언해준 후 할당은 나중에 해주거나 or 동적할당을 할 일이 생긴다 -> null값으로 초기화해놓는 것이 중요하다.
- `%p` : pointer형태로 value 할당하기 위해서

## 간접 참조 연산자
- 간접 참조 연산자 `*` : 포인터가 가리키는 값을 가져오는 연산자. cf)포인터 `*`
```
int i = 10;
int *p; //*가 나타내는 것 -> 나는 <포인터변수>이다
p = &i; //address i를 p라는 포인터변수에 할당해준다. 
printf("%d",*p); // 여기서의 *기호는 포인터 선언의 기호가 아니다! then what?! p라는 포인터변수를 참조할거야(화살표,pointer)
//어디를 가리키는데? 포인터 변수가 갖고 있는 주소값(변수 i의 주소)!
```
-> 주소 할당 메커니즘
- `i`라는 정수형 변수가 선언된다. i의 주소가 임의로 할당된다
- 그 후 포인터변수인 `p`라는 변수가 선언된다 -> 이 p에 대한 주소도 할당된다. 
- 포인터변수 p는 i의 주소값을 가져온다. i는 4 5 6 7 이고, 4가 address의 첫번째 수이기 때문에 i의 변수값은 4이다. 
- 그 변수값(i의 주소값)이 p라는 변수에 <담긴다> : box안에 4라는 값이 들어간다고 이해하면 된다. 
- `printf(...,*p);`p가 가리키는(pointer) 값(=4)을 따라가봐라(참조로서의 포인터) -> 따라가봤더니 10이다.
